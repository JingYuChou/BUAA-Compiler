# 怎么写`SSA`

`SSA` Static Single-Assignment 据说是一种非常好的优化，此时此刻的笔者还不知道他的分量，专门写一份博客去记录学习`SSA`的过程。

## 初始SSA

略，教程部分是说明形式的文档，相信学了`llvm`都可以看懂

## `mem2reg`

字面意思是把内存换成寄存器？下面来看看吧

### 插入`phi`指令

在这一个步骤里，我们会把构建SSA所需要插入的phi指令都一口气先插到里面。当我们遇到不同基本块汇集（converge）到同一个基本块的时候，便需要将phi指令插入到基本块中。看下面的例子

![image-20231126220752047](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20231126220752047.png)

其中D是B和C， E是C和D， A是entry和D的`join node`

在如果在B&C中对同一个Value进行了定义，那么就得往D中插入一个针对这个Value 的 phi指令。

实际情况是非常复杂的比如D之后有可能又回到了B或者C之类的，因此单一的`join node`是不够的，提出`join set`：

* 设$S$是一个基本块集合
* 当$n$为$S$中至少两个基本快$n_1n_2$的`join node`的时候，可以说$n$是$S$的一个`join node`
* 将$S$的所有`join node`汇聚起来就是`join set`，记作$J(S)$

所以这玩意咋用？很简单，对每个`Value`，求出他的所有定义集合$D_v$，然后对$J(D_v)$插入相应的`phi`指令就ok!听起来好像问题要解决了，但是仔细想想，这玩意的求解过程复杂的一批，所以计算机科学家们搞了图论中的一些概念来转化问题。

* **dominate**:如果CFG（流程控制图）中从起始节点到基本块`y`的路径都经过了基本快x，则说**x支配y**
* **strict dominate**:显然每个基本块都支配他自己，如果x支配y，$x \ne y$则**x严格支配y**
* **直接支配者**：严格支配n，且不严格支配任何严格支配n的节点的节点，说白话就是支配者中离n最近的一个

有一点听显然的：每个节点的直接支配者有且仅有一个（除了entry，这玩意是入口）

#### 支配边界(Dominate Frontier)

节点n的支配边界时CFG中刚刚号不被n支配的节点的集合，形式化的定义是：
$$
DF(x) = \{x | n支配x的前驱节点，n不严格支配x\}
$$
就是说，在此之间n对节点都是路径支配的，但是在这个集合中出现了其他的可能性，这些其实很好想的一点就是这些可能性并不是凭空产生的，所以说一个节点x，他时一个支配边界，那他必然是不止一个节点的支配边界，对于在这些块中定义的变量，如果这个节点x也对这个节点进行了定义，那么这个节点必然也是`join node`